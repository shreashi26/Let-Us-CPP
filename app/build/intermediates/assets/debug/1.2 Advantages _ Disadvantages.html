<b><font color="#E91E00">Advantages</font></b><br><br>

1. vendor-neutral: the C++ standard is the same in any platform or compiler<br>
2. industrial (as opposed to academic): evolved to satisfy the needs of software engineers, not computer scientists<br>
3. efficient. Compiles into highly optimized CPU-specific machine code with little or no runtime overhead.<br>
4. multi-paradigm: allows the use and penalty-free mixing of procedural, OOP, generic programming, functional programming, etc<br>
5. strictly statically typed (unlike Python for example): a large amount of logic (and sometimes even calculations) can be proved and performed at compile time, by the type checking/inferring system.<br>
6. has deterministic memory management (as opposed to Java, C#, and other languages with garbage collectors): the life time of every object is known with absolute precision, which makes destructors useful and RAII possible.<br><br>

<b><font color="#E91E00">Disadvantages</font></b><br><br>

1. very complex! The learning curve is steep and takes a long time to climb, especially for those who know C or C# or other superficially similar languages<br>
2. has the concept of "undefined behavior" (just like C) -- a large class of errors that neither compiler nor the runtime system is required to diagnose.<br>
3. has some design flaws, although they are largely fixed by boost libraries and the new language standard.<br>
4. lacks network and async I/O, graphics, concurrency, serialization, and many other facilities expected of modern languages, 
although that is also largely fixed by boost libraries and (as far as concurrency is concerned) the new language standard. 